WSL Installation:
https://learn.microsoft.com/en-us/windows/wsl/install

1. Open PowerShell in Admin Mode

2. Run:

    wsl --install

3. Restart Computer

4. (Optional) To see available linux distros, run:

    wsl --list --online

5. Install distro:

    wsl --install Ubuntu-22.04

6. Create username and password

7. Verify version by running:

    wsl -l -v

   Version should be 2.

Install WSL Extension in VSCode

Open Ubuntu, run:

    code .

ROS2 Humble Installation:
https://docs.ros.org/en/humble/Installation.html

In VSCode bash terminal:

1. Locale Configuration

    locale  # Check current locale settings
    sudo apt update && sudo apt install locales
    sudo locale-gen en_US en_US.UTF-8
    sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
    export LANG=en_US.UTF-8
    locale  # Confirm updated locale settings

2. Software Properties and Universe Repository

    sudo apt install software-properties-common
    sudo add-apt-repository universe

3. Curl Installation and ROS Key

    sudo apt update && sudo apt install curl -y
    sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg

4. ROS2 Sources Configuration
    
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null

5. Update and Upgrade
  
    sudo apt update
    sudo apt upgrade

6. ROS Desktop Installation

    sudo apt install ros-humble-desktop

7. ROS Environment Setup

    source /opt/ros/humble/setup.bash

8. ROS2 Command Check

    ros2 


Sourcing Setup.bash

Go to .bashrc in VSCode, add the following line at the end:

    source /opt/ros/humble/setup.bash

#############################################################################################################
The following will be in VSCode after opening it with "code ." using Ubuntu or connecting to WSL from VSCode.
#############################################################################################################

Running Executables

    sudo apt update
    sudo apt install ros-humble-turtlesim

See list of packages:

    ros2 pkg list

See list of <packages, executables>:

    ros2 pkg executables

See list of executables from turtlesim packages

    ros2 pkg executables turtlesim

[Optional] To find turtlesim:

        cd /opt/ros/humble
        code .
        ctrl + p
        search: turtlesim

It should be in: share/ament_index/resourse_index/packages

Running turtlesim:

To see options:

    ros2 run -h

To run an executable from a package:

    ros2 run <package_name> <executable_name>

To run turtlesim node:

    ros2 run turtelsim turtelsim_node

To run turtlesim teleop mode (controlable mode):

    ros2 run turtlesim turtle_teleop_key

/////////////////////////////////////////////////////////////////////////////
NOTE: 
    The way ROS works is that it sends and recieves data between nodes,
    basically executables, through different ways like topics, services,
    and actions.
/////////////////////////////////////////////////////////////////////////////

ROS2 Node Commands:

1. See ros2 node help:

    ros2 node -h

2. List currently running nodes:

    ros2 node list

3/4. Run the turtlesim node and try previous command.

5. See node info:

    ros2 node info <node_name>

    for turtlesim:

    ros2 node info /turtlesim

#############################################################################################################
The following commands may only work as intended if the required turtlesim nodes are active.
See commands in previous section for how to start them if you don't remember.
#############################################################################################################

ROS Topic:
Topics are connections between two nodes, like a publisher node and a subscriber node.
The publisher node sends data to a topic, or publishes it to the topic, and the subscriber node recieves that published data from the topic.
Here, there is always a stream of data being continuously published or subscribed.

To see list of topics:
    
    ros2 topic list

    to see details:

    ros2 topic list -t

Start rqt graph, uncheck hide boxes to see hidden topics:

    rqt_graph

To see topic output:

    ros2 topic echo <topic_name>

    for turtlesim, to see the cmd_velocity:

    ros2 topic echo /turtle1/cmd_vel

To see interface definition:

    ros2 interface show <type>

    ros2 interface show geometry_msgs/msg/Twist

Publish data to a topic:

    ros2 topic pub <topic_name> <msg_type> '<args>'

    To publish movement data to turtlesim:

    ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"

    here, the --once option runs the publish once to the topic.
    To publish the data at a specific rate continuously:

    ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"

    here, the --rate sets how many hertz, or how many times a second the topic is published to.

Echo the pose topic:

    ros2 topic echo /turtle1/pose

View topic frequency:

    ros2 topic hz <topic_name>

    for the turtlesim pose topic:

    ros2 topic hz /turtle1/pose


ROS Service
In services, data is not continuously published.
The service connects the server node and client node.
The client requests data and the server needs to respond before the client can recieve the data.

List all service names:

    ros2 service list

    To see the service types:
    ros2 service list -t

Another way to view service type:

    ros2 service type <service_name>

    for example,

    ros2 service type /clear

    this would return the service type of the /clear service.

To find services with a specific type:

    ros2 service find <service_type>

    for example,

    ros2 service find std_srvs/srv/Empty

    this returns all services with the type 'std_srvs/srv/Empty'.

To see interface:

    ros2 interface show <service_type>

    for example,

    ros2 interface show turtlesim/srv/Spawn

    this basically just shows you the basic data related to the service type, like its variables.

To call a service:

    ros2 service call <service_name> <service_type>

    for example,

    ros2 service call /clear std_srvs/srv/Empty

    this calls the clear service to clear the screen of the path made by the turtle.

    ros2 service call /spawn turtelsim/srv/Spawn "{x: 2, y: 2, theta: 0.2, name: ''}"

    this calls the spawn service to create a new turtle at the specified location.
    by default, this spawns the turtle off screen near the bottom left hand corner (you need to enlarge the screen to see it).


ROS Parameters

To see list of parameters:

    ros2 param list

To get parameter values:

    ros2 param get <node_name> <parameter_name>

    for example,

    ros2 param get /turtlesim background_g

    this shows the value for the window's background green value.

To set a parameter's value:

    ros2 param set <node_name> <parameter_name> <value>

    for example,

    ros2 param set /turtlesim background_g 255

    this sets the background_g value to 255.

To view all the parameters for a node:

    ros2 param dump <node_name>

    for example,

    ros2 param dump /turtlesim 

    this shows all the parameters and their values for the turtlesim node.

To store these values in a yaml file:

    ros2 param dump <node_name> > <yaml_file_name>.yaml

    for example,

    ros2 param dump /turtlesim > turtlesim.yaml

    this saves the parameters and their values in a yaml file.

To load parameters from a yaml file:

    ros2 param load <node_name> <yaml_file>.yaml

    for example,

    ros2 param load /turtlesim turtlesim.yaml

    this loads the parameter values in the yaml file into the turtlesim node.

To load the parameters on startup:

    ros2 run <package_name> <executable_name> --ros-args --params-file <file_name>

    for example,

    ros2 run turtlesim turtlesim_node --ros-args --params-file turtlesim.yaml


ROS Actions:
Actions also uses the server and client model but is slightly different.
With the data, the action also contains a goal, feedback, and results.

In the turtlesim, the rotation letters are actions.
You can see the action clients in node info at the bottom:

    ros2 node info /teleop_turtle

To see all the actions:

    ros2 action list

    to see the type:

    ros2 action list -t

To see action info:

    ros2 action info <action_name>

    for example,

    ros2 action info /turtle1/rotate_absolute

To see datat type for action:

    ros2 interface show turtlesim/action/RotateAbsolute

To send action goal:

    ros2 action send_goal <action_name> <action_type> <goal>

    for example,

    ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: 1.57}"


ROS Workspace
Holds all the files that we want to build and run.
You can have more than one workspace at the same level in the file directory.
The src (source) folder will contain all of our packages.

Colcon is a build tool that we use to build our packages.

1. Install colcon:

    sudo apt install python3-colcon-common-extensions

2. Create the workspace and navigate to it:

    mkdir -p ~/ros2_ws/src
    cd ~/ros2_ws

3. [Optional] Add some source code to test building:

    git clone https://github.com/ros/ros_tutorial.git -b humble

4. Setup colcon tab completion:

    echo "source /user/share/colcon_argcomplete/hook/colcon-argcomplete.bash" >> ~/.bashrc

5. Build with colcon from ~/ros2_ws:

    colcon build --symlink-install

    This creates symbolic links (symlinks) to the original files in the source or build directories instead of making copies.

6. [Optional] See the folders that were created:

    ls

7. Source overlay from ~/ros2_ws:

    source install/local_setup.bash

8. Run node:

    ros2 run turtlesim turtlesim_node

9. To verify you are modifying your package and not the previous one, edit the name of the window.
   
    ctrl + p
    search turtle_frame.cpp
    modify line 52 (or where ever the setWindowTitle() funciton is) to whatever you want.

10. Rebuild, source, then run:

    colcon build --symlink-install
    source install/local_setup.bash
    ros2 run turtlesim turtlesim_node


How to create your own package:

prereq: install colcon and create your workspace.

1. Create package from ~/ros2_ws/src:

    ros2 pkg create --build-type ament_cmake --node-name <node_name> <package_name>

    for example,

    ros2 pkg create --build-type ament_cmake --node-name my_node my_package

2. Check the files and folders that it made:

    include/my_package
    src/my_node.cpp
    CMakeLists.txt
    package.xml

3. Build that package from ~/ros2_ws:

    colcon build --packages-select my_package

4. Source:

    source install/local_setup.bash

5. Run Node:

    ros2 run my_package my_node

#############################################################################################################
The following will be done after the workspace is made. 
Make sure to have the CMake extension by txns installed in VSCode.
#############################################################################################################

Publisher and Subscriber C++

1. Create package from ~/ros2_ws/src:

    cd ~/ros2_ws/src
    ros2 pkg create --build-type ament_cmake cpp_pubsub

2. Make the publisher_memeber_function.cpp and subscriber_member_function.cpp files in the src of cpp_pubsub package.

3. Update package.xml (add the ADDED section)

4. Update CMakeLists.txt (add the ADDED section)

5. [Optional] Check for missing dependencies from ~/ros2_ws:

    rosdep install -i --from-path src --rosdistro humble -y

6. Build with colcon from ~/ros2_ws:

    colcon build --packages-select cpp_pubsub

7. In one terminal, run the talker from ~/ros2_ws:

    cd ~/ros2_ws
    source install/setup.bash
    ros2 run cpp_pubsub talker

8. In another terminal, run the listener from ~/ros2_ws

    cd ~/ros2_ws
    source install/setup.bash
    ros2 run cpp_pubsub listener


Publisher and Subscriber python3

1. Create package from ~/ros2_ws/src:

    cd ~/ros2_ws/src
    ros2 pkg create --build-type ament_python py_pubsub

2. Make the publisher_memeber_function.py and subscriber_member_function.py files in the py_pubsub sub folder of the py_pubsub package.

3. Update package.xml (add the ADDED section)

4. Update setup.py (add the ADDED section)

5. [Optional] Check for missing dependencies from ~/ros2_ws:

    rosdep install -i --from-path src --rosdistro humble -y

6. Build with colcon from ~/ros2_ws:

    colcon build --packages-select py_pubsub

7. In one terminal, run the talker from ~/ros2_ws:

    cd ~/ros2_ws
    source install/setup.bash
    ros2 run py_pubsub talker

8. In another terminal, run the listener from ~/ros2_ws:

    cd ~/ros2_ws
    source install/setup.bash
    ros2 run py_pubsub listener

#############################################################################################################
#############################################################################################################

URDF Files

URDF (Unified Robotics Description Format) File: and .xml file used to describe the visual, physics, and connections
of a robot with joints and links.
It has two sections: link and joint

The general structure is as such:
<?xml version="1.0"?>
<robot name="robot_name">
    <link name="link_name">
        <visual>
        </visual>

        <collision>
        </collision>

        <inertial>
        </inertial>
    </link>

    <joint name="join_name" ...>
        <axis .../>
        <parent link .../>
        <child link .../>
        <origin .../>
    </joint>
</robot>


Links in URDF Files

Used to describe a segment of a robot, where you can define the visual, collision, and inertial properties. The geometry
and origin properties are used in visual and collision properties to describe the shape and location of the link.

General Structure:
<link name="link_name">
    <visual> // optional
        <geometry> // required (if there is a visual)
            // geometry specific code
        </geometry>
        <origin rpy="r p y" xyz="x y z"/> // optional
        <material name="color_name"/> // optional
    </visual>

    <collision> // optional
        <geometry> // required (if there is a visual)
            // geometry specific code
        </geometry>
        <origin rpy="r p y" xyz="x y z"/> // optional
    </collision>

    <inertial> // optional
        <mass value = "mass_in_kg"/>
        <inertia
            ixx="ixx" ixy="ixy" ixz="ixz"
            iyy="iyy" iyz="iyz" izz="izz"/>
    </inertial>
</link>

Visual
The visual is used to describe the geometry of the link. Usually this can be an accurate representation of the robot or just
a simplified version depending on the goal. For accurate models, one can obtain the model from a 3D modeling software and export
the .stl files for the geometry.

Types of Geometries in URDF File:
Units for the geometries are in SI units, so meters for all lengths. For the mesh, the file types can be .stl or .dae files.

Geometry            Geometry Specific Code
box                 <box size="x y z"/>
sphere              <sphere radius="r"/>
cylinder            <cylinder radius="r" length="l"/>
mesh                <mesh filename="file_path" scale="x y z"/>

Origin (rpy and xyz):
Used to define the rotation (radians) using roll (x), pitch (y), yaw (y) and the translation (meters) using x, y, z relative to the 
link's coordinate frame. The order of rotation for rpy is ZYX, so first rotate about X axis, then Y axis and finally Z axis.
The rotation operation is applied first and then the translation.

For visual and collision, origin describes how the geometry is transformed relative to the link's frame.

For inertial, origin describes the location of the center of mass relative to the link's frame.

Axis Colors:
Axis    Color
X       Red 
Y       Green 
Z       Blue

Material:
Used to define the colors and transparency of the color by using rgba, normalized between 0 and 1.

<material name="color_name">
    <color rgba="r g b a"/>
</material>

Common Colors:
color_name          r g b a 
red                 1 0 0 1
green               0 1 0 1
blue                0 0 1 1
yellow              1 1 0 1
cyan                0 1 1 1

Collision
Used to describe a bounding shape around the link for collision detection. This is usually done using simple shapes
for faster calculation when detecting collisions between other collsion bounding shapes.

Inertial
Used to describe the inertia (kg * m^2) about the link's center of mass and the mass (kg) of the link.


Joints in URDF Files
Used to describe the connections between two links, a parent link and a child link.

General Structure:
<joint name="join_name" type="joint_type">
    // optional
    <parent link="parent_link_name"/>
    <child link="child_link_name"/>
    
    // required
    <axis rpy="r p y" xyz="x y z"/>
    <origin rpy="r p y" xyz="x y z"/>
    <limit lower="lower" upper="upper" effort="max_effort" velocity="max_vel">
    <dynamics damping="damp_coef" friciton="fric_coef">
</joint>

Types of Joints:
-> fixed: no motion between links
-> continuous: rotation about axis, not limit
-> revolute: rotation about axis, with limits (in radians)
-> prismatic: translation about axis
-> floating: 6 Degrees of Freedom (DOF) (3 translation, 3 rotation)
-> planar: motion on plane (2 translation, 1 rotation)

Parent and Child Link:
The parent link is the link before the joint and the child link is the link after the joint.

Origin and Axis:
The origin describes the location of the child frame relative to the parent frame.
The axis describes the axis of rotation for the joint. 

Dynamics:
Includes daming expressed in Ns/m (Newtons/meter) and friction (static friction) expressed in N (Newtons).

Limit:
For revolute and prismatic joints only.
The lower and upper field are in radians and meters respectively, 
the effort is the max effor in Nm (Newton meters), and velocity is max velocity (radians/s).
